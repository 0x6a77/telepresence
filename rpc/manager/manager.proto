syntax = "proto3";

// The "manager" package describes the server implemented by the
// in-cluster Manager, which is spoken to by the Agent (app-sidecar),
// the on-laptop Connector (user-daemon), the on-laptop CLI. and the
// SystemA cloud service.
package telepresence.manager;

import "google/protobuf/empty.proto";

option go_package = "github.com/datawire/telepresence2/pkg/rpc/manager";

// ClientInfo is the self-reported metadata that the on-laptop
// Telepresence client reports whenever it connects to the in-cluster
// Manager.
message ClientInfo {
  string name = 1;  // user@hostname
  string install_id = 2;
  string product = 3;  // "telepresence"
  string version = 4;
  string license_key = 5;
  string bearer_token = 6;
}

// AgentInfo is the self-reported metadata that an Agent (app-sidecar)
// reports at boot-up when it connects to the Telepresence Manager.
message AgentInfo {
  string name = 1; // namespace/name of the Deployment
  string hostname = 2;
  string product = 3; // distinguish open source, our closed source, someone else's thing
  string version = 4;

  // "Mechanisms" are the ways that an Agent can decide handle
  // incoming requests, and decide whether to send them to the
  // in-cluster service, or whether to intercept them.  The "tcp"
  // mechanism is the only one in Telepresence open source, and
  // handles things at the TCP-level and either intercepts all TCP
  // streams or doesn't intercept anything.  Other Agents than the
  // Telepresence one may implement more mechanisms, such as
  // Ambassador Labs' "Service Preview" Agent which implements the
  // "http" mechanism which handles th "http" mechanism, which handles
  // things at the HTTP-request-level and can decide to intercept
  // individual HTTP requests based on the request headers.
  message Mechanism {
    string name = 1; // "tcp" or "http" or "grpc" or ...
    string product = 2; // distinguish open source, our closed source, someone else's thing
    string version = 3;
  }

  // This is a list of the mechanisms that the Agent advertises that
  // it supports.
  repeated Mechanism mechanisms = 5;
}

message InterceptSpec {
  // A human-friendly name for this intercept.  This is usally the
  // same as the agent name below; the name/namespace of the
  // Deployment, but it could be something else.  It is invalid for
  // the same client to attempt to create multiple intercepts with the
  // same name.
  string name = 1;

  // Same as ClientInfo.Name; "user@hostname".
  string client = 2;

  // Same as AgentInfo.Name; "name/namespace" of the Deployment.
  string agent = 3;

  // How to decide which subset of requests to that agent to intercept.
  string mechanism = 4;

  /*
     additional mechanism-specific info
     - header match patterns would go here
     - perhaps a JSON blob for the Agent's mechanism implementation to parse
     - how does the client decide to create this blob?
     - perhaps just pass all the unrecognized CLI arguments? or all of them?
     - maybe always pass client's install id to use for x-service-preview matches?
   */
  string additional = 5;

  string target_host = 6;
  int32 target_port = 7;
}

enum InterceptDispositionType {
  UNSPECIFIED = 0;

  ACTIVE = 1;
  WAITING = 2;

  // Failure states

  NO_CLIENT = 3;
  NO_AGENT = 4;
  NO_MECHANISM = 5;
  NO_PORTS = 6;
  AGENT_ERROR = 7;
}


message InterceptInfo {
  InterceptSpec spec = 1;

  // manager_port is the port on the manager that the agent should
  // send intercepted traffic to.  This gets set by the manager when
  // the agent calls ReviewIntercept setting the disposition to
  // ACTIVE.
  int32 manager_port = 2;

  // preview_domain is the SystemA domain that will proxy in traffic
  // to this intercept.  This gets set by the manager at some
  // likely-to-change point in the process of setting up the
  // intercept.
  string preview_domain = 7;

  InterceptDispositionType disposition = 3;
  string message = 4;
  string id = 5;
  SessionInfo client_session = 6;
}

message SessionInfo {
  string session_id = 1;
}

message AgentInfoSnapshot {
  repeated AgentInfo agents = 1;
}

message InterceptInfoSnapshot {
  repeated InterceptInfo intercepts = 1;
}

message CreateInterceptRequest {
  SessionInfo session = 1;
  InterceptSpec intercept_spec = 2;
}

message RemoveInterceptRequest2 {
  SessionInfo session = 1;
  string name = 2;
}

message ReviewInterceptRequest {
  SessionInfo session = 1;
  string id = 2;
  InterceptDispositionType disposition = 3;
  string message = 4;
}

message RemainRequest {
  SessionInfo session = 1;
  string bearer_token = 2;
}

// VersionInfo2 is different than telepresence.common.VersionInfo in
// that it does not contain an 'api_version' integer.
message VersionInfo2 {
  string version = 2;
}

service Manager {
  // Version returns the version information of the Manager.
  rpc Version(google.protobuf.Empty) returns (VersionInfo2);

  // Presence

  // ArriveAsClient establishes a session between a client and the Manager.
  rpc ArriveAsClient(ClientInfo) returns (SessionInfo);

  // ArriveAsAgent establishes a session between an agent and the Manager.
  rpc ArriveAsAgent(AgentInfo) returns (SessionInfo);

  // Remain indicates that the session is still valid, and potentially
  // updates the auth token for the session.
  rpc Remain(RemainRequest) returns (google.protobuf.Empty);

  // Depart terminates a session.
  rpc Depart(SessionInfo) returns (google.protobuf.Empty);

  // Watches

  // WatchAgents notifies a client of the set of known Agents.
  rpc WatchAgents(SessionInfo) returns (stream AgentInfoSnapshot);

  // WatchIntercepts notifies a client or agent of the set of intercepts
  // relevant to that client or agent.
  rpc WatchIntercepts(SessionInfo) returns (stream InterceptInfoSnapshot);

  // CRUD

  // CreateIntercept lets a client create an intercept.  It will be
  // created in the "WATING" disposition, and it will remain in that
  // state until until the Agent (the app-sidecar) calls
  // ReviewIntercept() to transition it to the "ACTIVE" disposition
  // (or one of the error dispositions).
  rpc CreateIntercept(CreateInterceptRequest) returns (InterceptInfo);

  // RemoveIntercept lets a client remove an intercept.
  rpc RemoveIntercept(RemoveInterceptRequest2) returns (google.protobuf.Empty);

  // ReviewIntercept lets an agent approve or reject an intercept by
  // changing the disposition from "WATING" to "ACTIVE" or to an
  // error, and setting a human-readable status message.
  rpc ReviewIntercept(ReviewInterceptRequest) returns (google.protobuf.Empty);
}
