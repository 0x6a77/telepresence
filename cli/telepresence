#!/usr/bin/env python
"""
Telepresence CLI tool, a thin wrapper around the
datawire/telepresence-local Docker image.

Should be written to support Python 2 and Python 3 for ease of distribution.
"""

from __future__ import print_function

import argparse
import os
import os.path
from random import randint
from subprocess import check_call
from tempfile import mkdtemp
from time import sleep

VERSION = "0.5"


def parse_args():
    """Create a new ArgumentParser and parse sys.argv."""
    parser = argparse.ArgumentParser()
    parser.add_argument('--version', action='version', version=VERSION)
    group_deployment = parser.add_mutually_exclusive_group(required=True)
    group_deployment.add_argument(
        "--deployment",
        help=("The name of the Kubernetes Deployment where the " +
              "datawire/telepresence-k8s image is running."))
    group_deployment.add_argument(
        '--new-deployment',
        action="store_const",
        const=None,
        dest="deployment",
        help=("Create a new Deployment in Kubernetes where the "
              "datawire/telepresence-k8s image will run."))
    parser.add_argument(
        "--expose",
        type=int,
        action='append',
        default=[],
        help=("Port number in local container that will be " +
              "exposed to Kubernetes."))
    parser.add_argument(
        "--proxy",
        action='append',
        default=[],
        help="<host>:<port> that will be proxied via Kubernetes.")
    parser.add_argument(
        "docker_run_args",
        metavar="DOCKER-RUN-ARGUMENTS",
        nargs=argparse.REMAINDER,
        help=("All remaininding arguments, to be passed to "
              "`docker run`, e.g. '-i -t alpine:3.5 /bin/sh'."))
    return parser.parse_args()


def docker_command():
    docker_path = "/var/run/docker.sock"
    if (os.path.exists(docker_path) and not os.access(docker_path, os.W_OK)):
        return ["sudo", "docker"]
    else:
        return ["docker"]


def start_command(args):
    """`telepresence start`."""
    if args.deployment is None:
        # This implies --new-deployment, so we generate a new name and then
        # start the Deployment:
        args.deployment = "deployment-" + str(randint(1, 999999))
        command = [
            "kubectl", "run", "--generator", "deployment/v1beta1",
            args.deployment, "--image=datawire/telepresence-k8s:" + VERSION
        ]
        for port in args.expose:
            command.append("--port={}".format(port))
        check_call(command)
        sleep(5) # XXX oh god
        # XXX cleanup Deployment at shutdown?

    home_path = os.path.expanduser("~")
    docker_cmd = docker_command() + [
        "run",
        # Delete when exited:
        "--rm",
        # Name matches Deployment name:
        "--name={}".format(args.deployment),
        # Mount $HOME so we have access to kubectl configuration:
        "-v", home_path + ":/opt:ro",
        # Minikube looks in absolute path for home, so also mount in way that
        # matches host path:
        "-v", "{}:{}:ro".format(home_path, home_path),
    ]

    tempdir = mkdtemp()

    docker_cmd.extend([
        # Mount local directory, where env file will be written out:
        "-v",
        tempdir + ":/output",
        # Name of container:
        "datawire/telepresence-local:" + VERSION,
        # Arguments: <uid>, <deployment-name>
        str(os.getuid()),
        args.deployment,
        # Arguments: <port1,port2>, <proxy1,proxy2>...
        ",".join(map(str, args.expose)),
        ",".join(args.proxy)
    ])
    check_call(docker_cmd)
    return tempdir


def run_local_command(args, tempdir):
    """`telepresence run-local`."""
    # XXX argparse sucks need to switch to something else
    if args.docker_run_args and args.docker_run_args[0] == "--":
        args.docker_run_args.pop(0)
    # Wait for proxy container to write out env file, indicating we're good to
    # go:
    out_env = os.path.join(tempdir, "out.env")
    while not os.path.exists(out_env):
        sleep(1)
    command = docker_command() + [
        "run",
        "--net=container:" + args.deployment,
        "--env-file={}".format(out_env)
    ] + args.docker_run_args
    check_call(command)


def main():
    args = parse_args()
    tempdir = start_command(args)
    run_local_command(args, tempdir)


if __name__ == '__main__':
    main()
