#!/usr/bin/env python
"""
Telepresence CLI tool, a thin wrapper around the
datawire/telepresence-local Docker image.

Should be written to support Python 2 and Python 3 for ease of distribution.
"""

from __future__ import print_function

import argparse
import os
import os.path
from random import randint
from subprocess import Popen

VERSION = "0.3"


def parse_args():
    """Create a new ArgumentParser and parse sys.argv."""
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title="Subcommands")
    start_parser = subparsers.add_parser(
        "start", help="Start the proxy to the remote Kubernetes cluster.")
    group_deployment = start_parser.add_mutually_exclusive_group(required=True)
    group_deployment.add_argument(
        "--deployment",
        nargs=1,
        help=("The name of the Kubernetes Deployment where the " +
              "datawire/telepresence-k8s image is running."))
    group_deployment.add_argument(
        '--new-deployment',
        action="store_const",
        const=None,
        dest="deployment",
        help=("Create a new Deployment in Kubernetes where the "
              "datawire/telepresence-k8s image will run."))
    start_parser.add_argument(
        "--expose",
        type=int,
        action='append',
        default=[],
        help=("Port number in local container that will be " +
              "exposed to Kubernetes."))
    start_parser.add_argument(
        "--proxy",
        action='append',
        default=[],
        help="<host>:<port> that will be proxied via Kubernetes.")
    runlocal_parser = subparsers.add_parser(
        "run-local",
        help=(
            "Run a command locally in Docker in a way that is "
            "exposed to remote Kubernetes. Accepts `docker run` "
            "command-line arguments."
        ))
    runlocal_parser.add_argument(
        "--deployment",
        nargs=1, required=True,
        help=("The name of the Kubernetes Deployment where the " +
              "datawire/telepresence-k8s image is running."))
    runlocal_parser.add_argument(
        "docker_run_args",
        metavar="DOCKER-RUN-ARGUMENTS",
        nargs=argparse.REMAINDER,
        help=("All remaininding arguments, to be passed to "
              "`docker run`, e.g. '-i -t alpine:3.5 /bin/sh'."))
    return parser.parse_args()


def need_sudo():
    docker_path = "/var/run/docker.sock"
    if (os.path.exists(docker_path) and not os.access(docker_path, os.W_OK)):
        return True
    return False


def main():
    minikube_path = os.path.expanduser("~/.minikube")
    kube_path = os.path.expanduser("~/.kube")
    args = parse_args()

    # XXX if new-deployment, kubectl apply a new deployment...
    # "deployment-" + str(randint()),

    docker_cmd = [
        "docker",
        "run",
        # Delete when exited:
        "--rm",
        # Name matches Deployment name:
        "--name={}".format(args.deployment_name),
        # Mount .kube so we have access to kubectl configuration:
        "-v",
        kube_path + ":/opt/.kube:ro",
    ]

    if os.path.exists(minikube_path):
        docker_cmd.extend([
            # Mount minikube directory, if available, for CA certificates:
            "-v",
            "{}:{}:ro".format(minikube_path, minikube_path),
        ])
    docker_cmd.extend([
        # Mount local directory, where env file will be written out:
        "-v",
        os.getcwd() + ":/output",
        # Name of container:
        "datawire/telepresence-local:" + VERSION,
        # Arguments: <uid>, <deployment-name>
        str(os.getuid()),
        args.deployment_name,
        # Arguments: <port1,port2>, <proxy1,proxy2>...
        ",".join(map(str, args.expose)),
        ",".join(args.proxy)
    ])
    if need_sudo():
        docker_cmd.insert(0, "sudo")
    p = Popen(docker_cmd)
    p.wait()


if __name__ == '__main__':
    main()
