package daemon

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"

	"github.com/datawire/dlib/dexec"
	"github.com/datawire/dlib/dgroup"
	"github.com/datawire/dlib/dlog"
	"github.com/datawire/telepresence2/pkg/client/daemon/dns"
	"github.com/datawire/telepresence2/pkg/subnet"
)

const kubernetesZone = "cluster.local"

type resolveFile struct {
	domain      string
	nameservers []net.IP
	search      []string
}

func readResolveFile(fileName string) (*resolveFile, error) {
	fl, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	defer fl.Close()
	sc := bufio.NewScanner(fl)
	rf := resolveFile{}
	line := 0
	for sc.Scan() {
		line++
		txt := strings.TrimSpace(sc.Text())
		if len(txt) == 0 || strings.HasPrefix(txt, "#") {
			continue
		}
		fields := strings.Fields(txt)
		fc := len(fields)
		if fc == 0 {
			continue
		}
		key := fields[0]
		if fc == 1 {
			return nil, fmt.Errorf("%q must have a value at %s line %d", key, fileName, line)
		}
		value := fields[1]
		switch key {
		case "domain":
			if fc != 2 {
				return nil, fmt.Errorf("%q can only have one value at %s line %d", key, fileName, line)
			}
			rf.domain = value
		case "nameserver":
			if fc != 2 {
				return nil, fmt.Errorf("%q can only have one value at %s line %d", key, fileName, line)
			}
			ip := net.ParseIP(value)
			if ip == nil {
				return nil, fmt.Errorf("value %q for %q is not a valid IP at %s line %d", value, key, fileName, line)
			}
			rf.nameservers = append(rf.nameservers, ip)
		case "search":
			rf.search = fields[1:]
		default:
			// This reader doesn't do options just yet
			return nil, fmt.Errorf("%q is not a recognized key at %s line %d", key, fileName, line)
		}
	}
	return &rf, nil
}

func (r *resolveFile) write(fileName string) error {
	buf := bytes.NewBufferString("# Generated by telepresence\n")
	if r.domain != "" {
		fmt.Fprintf(buf, "domain %s\n", r.domain)
	}
	for _, ns := range r.nameservers {
		fmt.Fprintf(buf, "nameserver %s\n", ns)
	}

	if len(r.search) > 0 {
		buf.WriteString("search")
		for _, s := range r.search {
			buf.WriteByte(' ')
			buf.WriteString(s)
		}
		buf.WriteByte('\n')
	}
	return ioutil.WriteFile(fileName, buf.Bytes(), 0644)
}

func (r *resolveFile) setSearchPaths(paths ...string) {
	ps := make([]string, 0, len(paths)+1)
	for _, p := range paths {
		p = strings.TrimSuffix(p, ".")
		if len(p) > 0 && p != r.domain {
			ps = append(ps, p)
		}
	}
	ps = append(ps, r.domain)
	r.search = ps
}

// dnsServerWorker places a file under the /etc/resolver directory so that it is picked up by the
// MacOS resolver. The file is configured with a single nameserver that points to the local IP
// that the Telepresence DNS server listens to. The file is removed, and the DNS is flushed when
// the worker terminates
//
// For more information about /etc/resolver files, please view the man pages available at
//
//   man 5 resolver
//
// or, if not on a Mac, follow this link: https://www.manpagez.com/man/5/resolver/
func (o *outbound) dnsServerWorker(c context.Context) error {
	resolverDirName := filepath.Join("/etc", "resolver")
	resolverFileName := filepath.Join(resolverDirName, "telepresence.local")

	err := os.MkdirAll(resolverDirName, 0755)
	if err != nil {
		return err
	}

	loopBackCIDR, err := subnet.FindAvailableLoopBackClassC()
	if err != nil {
		return err
	}

	// Place the DNS server in the private network at x.x.x.2
	dnsIP := make(net.IP, len(loopBackCIDR.IP))
	copy(dnsIP, loopBackCIDR.IP)
	dnsIP[len(dnsIP)-1] = 2

	rf := resolveFile{
		domain:      kubernetesZone,
		nameservers: []net.IP{dnsIP},
		search:      []string{kubernetesZone},
	}
	if err = rf.write(resolverFileName); err != nil {
		return err
	}
	dlog.Infof(c, "Generated new %s", resolverFileName)

	o.setSearchPathFunc = func(c context.Context, paths []string) {
		dlog.Infof(c, "setting search paths %s", strings.Join(paths, " "))
		rf, err := readResolveFile(resolverFileName)
		if err != nil {
			dlog.Error(c, err)
			return
		}
		rf.setSearchPaths(paths...)
		if err = rf.write(resolverFileName); err != nil {
			dlog.Error(c, err)
			return
		}
	}

	// Up our loopback device
	if err = dexec.CommandContext(c, "ifconfig", "lo0", "alias", dnsIP.String(), "up").Run(); err != nil {
		return err
	}

	defer func() {
		// recover a panic. The DNS must be reset, no matter what
		r := recover()
		// Remove the resolver file
		_ = os.Remove(resolverFileName)

		// Remove loopback device
		_ = exec.Command("ifconfig", "lo0", "-alias", dnsIP.String()).Run()

		dns.Flush()
		if r != nil {
			// Propagate panic, it's of no interest here
			panic(r)
		}
	}()

	// Start local DNS server
	initDone := &sync.WaitGroup{}
	initDone.Add(1)
	g := dgroup.NewGroup(c, dgroup.GroupConfig{})
	g.Go("Server", func(c context.Context) error {
		v := dns.NewServer(c, []string{fmt.Sprintf("%s:53", dnsIP.String())}, "", func(domain string) string {
			if r := o.resolveNoNS(domain); r != nil {
				return r.Ip
			}
			return ""
		})
		return v.Run(c, initDone)
	})
	initDone.Wait()

	dns.Flush()

	g.Go(proxyWorker, o.proxyWorker)
	return g.Wait()
}
